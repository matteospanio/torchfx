
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>torchfx.effect &#8212; TorchFX 1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=6f8f3740"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const defaultStyle = document.createElement('style');
defaultStyle.textContent = `pre.mermaid {
    /* Same as .mermaid-container > pre */
    display: block;
    width: 100%;
}

pre.mermaid > svg {
    /* Same as .mermaid-container > pre > svg */
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}
`;
document.head.appendChild(defaultStyle);

const fullscreenStyle = document.createElement('style');
fullscreenStyle.textContent = `.mermaid-container {
    display: flex;
    flex-direction: row;
    width: 100%;
}

.mermaid-container > pre {
    display: block;
    width: 100%;
}

.mermaid-container > pre > svg {
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}

.mermaid-fullscreen-btn {
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 95vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-container-fullscreen pre.mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen .mermaid svg {
    height: 100% !important;
    width: 100% !important;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}`;
document.head.appendChild(fullscreenStyle);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const load = async () => {
    await mermaid.run();

    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");

    if ("False" === "True") {
        const mermaids_to_add_zoom = -1 === -1 ? all_mermaids.length : -1;
        if(mermaids_to_add_zoom > 0) {
            var svgs = d3.selectAll("");
            if(all_mermaids.length !== mermaids_processed.length) {
                setTimeout(load, 200);
                return;
            } else if(svgs.size() !== mermaids_to_add_zoom) {
                setTimeout(load, 200);
                return;
            } else {
                svgs.each(function() {
                    var svg = d3.select(this);
                    svg.html("<g class='wrapper'>" + svg.html() + "</g>");
                    var inner = svg.select("g");
                    var zoom = d3.zoom().on("zoom", function(event) {
                        inner.attr("transform", event.transform);
                    });
                    svg.call(zoom);
                });
            }
        }
    } else if(all_mermaids.length !== mermaids_processed.length) {
        // Wait for mermaid to process all diagrams
        setTimeout(load, 200);
        return;
    }

    const darkTheme = isDarkTheme();

    // Stop here if not adding fullscreen capability
    if ("True" !== "True") return;

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-container-fullscreen${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-container-fullscreen');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    let previousScrollOffset = [window.scrollX, window.scrollY];

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = ''
        window.scrollTo({left: previousScrollOffset[0], top: previousScrollOffset[1], behavior: 'instant'});
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.style.opacity = '50%';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            previousScrollOffset = [window.scroll, window.scrollY];
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.sdisplay = 'block';

                if ("False" === "True") {
                    setTimeout(() => {
                        const g = svg.querySelector('g');
                        if (g) {
                            var svgD3 = d3.select(svg);
                            svgD3.html("<g class='wrapper'>" + svgD3.html() + "</g>");
                            var inner = svgD3.select("g");
                            var zoom = d3.zoom().on("zoom", function(event) {
                                inner.attr("transform", event.transform);
                            });
                            svgD3.call(zoom);
                        }
                    }, 100);
                }
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", load);
</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/torchfx/effect';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" /> 
<link
  rel="alternate"
  type="application/atom+xml"
  href="../../blog/index/atom.xml"
  title="TorchFX Blog"
/>
  
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/tfx_black.svg" class="logo__image only-light" alt=""/>
    <img src="../../_static/tfx.svg" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">TorchFX</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guides/index.html">
    Guides
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../blog/index.html">
    Blog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../glossary.html">
    Glossary
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/matteospanio/torchfx" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torchfx/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../guides/index.html">
    Guides
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/index.html">
    API Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../blog/index.html">
    Blog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../glossary.html">
    Glossary
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/matteospanio/torchfx" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torchfx/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">torchfx.effect</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                   <h1>Source code for torchfx.effect</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Audio effects and transformations with PyTorch integration.</span>

<span class="sd">This module provides the FX abstract base class and built-in audio effects</span>
<span class="sd">for time-domain signal processing. All effects inherit from torch.nn.Module,</span>
<span class="sd">enabling GPU acceleration, gradient computation, and seamless integration with</span>
<span class="sd">PyTorch&#39;s ecosystem.</span>

<span class="sd">Effects can be applied using the pipeline operator (|) with Wave objects or</span>
<span class="sd">called directly on tensors. The module supports extensibility through the</span>
<span class="sd">strategy pattern and custom effect creation.</span>

<span class="sd">The FX Base Class</span>
<span class="sd">-----------------</span>
<span class="sd">All effects inherit from the FX abstract base class, which combines</span>
<span class="sd">torch.nn.Module with ABC (Abstract Base Class) requirements. This ensures</span>
<span class="sd">effects are compatible with PyTorch&#39;s module system while enforcing a</span>
<span class="sd">consistent interface across all effect implementations.</span>

<span class="sd">Inheriting from nn.Module provides:</span>
<span class="sd">    - GPU/CPU device management (.to(), .cuda(), .cpu())</span>
<span class="sd">    - Parameter and buffer registration</span>
<span class="sd">    - Integration with nn.Sequential for effect chaining</span>
<span class="sd">    - Serialization support (state_dict, load_state_dict)</span>
<span class="sd">    - Gradient computation capabilities (when not using @torch.no_grad())</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">FX : Abstract base class</span>
<span class="sd">    Abstract base class for all effects and filters. Defines the interface</span>
<span class="sd">    that all effects must implement: __init__ and forward methods.</span>

<span class="sd">Built-in Effects</span>
<span class="sd">----------------</span>
<span class="sd">Gain : Volume adjustment</span>
<span class="sd">    Adjust signal amplitude using amplitude, dB, or power gain modes with</span>
<span class="sd">    optional clamping to prevent clipping.</span>
<span class="sd">Normalize : Amplitude normalization</span>
<span class="sd">    Normalize waveforms to target peak using configurable strategies including</span>
<span class="sd">    peak, RMS, percentile, and per-channel normalization.</span>
<span class="sd">Reverb : Spatial effects</span>
<span class="sd">    Simple reverb using feedback delay network for creating spatial ambiance.</span>
<span class="sd">Delay : Echo effects</span>
<span class="sd">    Multi-tap delay with BPM synchronization, musical time divisions, and</span>
<span class="sd">    stereo processing strategies (mono, ping-pong).</span>

<span class="sd">Strategy Pattern Components</span>
<span class="sd">----------------------------</span>
<span class="sd">NormalizationStrategy : Abstract normalization strategy</span>
<span class="sd">    Base class for normalization algorithms with concrete implementations:</span>
<span class="sd">    PeakNormalizationStrategy, RMSNormalizationStrategy,</span>
<span class="sd">    PercentileNormalizationStrategy, PerChannelNormalizationStrategy,</span>
<span class="sd">    CustomNormalizationStrategy.</span>
<span class="sd">DelayStrategy : Abstract delay strategy</span>
<span class="sd">    Base class for delay processing behaviors with concrete implementations:</span>
<span class="sd">    MonoDelayStrategy, PingPongDelayStrategy.</span>

<span class="sd">See Also</span>
<span class="sd">--------</span>
<span class="sd">torchfx.Wave : Wave class for audio I/O and pipeline operations</span>
<span class="sd">torchfx.filter : Filter-based audio processing</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">Apply effects using the pipeline operator:</span>

<span class="sd">&gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">&gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">&gt;&gt;&gt; processed = wave | fx.Gain(0.5) | fx.Normalize(peak=0.8)</span>

<span class="sd">Apply effects directly to tensors:</span>

<span class="sd">&gt;&gt;&gt; import torch</span>
<span class="sd">&gt;&gt;&gt; waveform = torch.randn(2, 44100)</span>
<span class="sd">&gt;&gt;&gt; gain = fx.Gain(2.0)</span>
<span class="sd">&gt;&gt;&gt; louder = gain(waveform)</span>

<span class="sd">Create custom effects by subclassing FX:</span>

<span class="sd">&gt;&gt;&gt; class CustomEffect(fx.effect.FX):</span>
<span class="sd">...     def __init__(self, param: float) -&gt; None:</span>
<span class="sd">...         super().__init__()</span>
<span class="sd">...         self.param = param</span>
<span class="sd">...</span>
<span class="sd">...     @torch.no_grad()</span>
<span class="sd">...     def forward(self, waveform: torch.Tensor) -&gt; torch.Tensor:</span>
<span class="sd">...         return waveform * self.param</span>

<span class="sd">Chain multiple effects in a pipeline:</span>

<span class="sd">&gt;&gt;&gt; reverb = fx.Reverb(delay=4410, decay=0.6, mix=0.3)</span>
<span class="sd">&gt;&gt;&gt; delay = fx.Delay(bpm=128, delay_time=&quot;1/8&quot;, feedback=0.4, mix=0.2)</span>
<span class="sd">&gt;&gt;&gt; result = wave | reverb | delay</span>

<span class="sd">Use strategy pattern for extensibility:</span>

<span class="sd">&gt;&gt;&gt; # Custom normalization strategy</span>
<span class="sd">&gt;&gt;&gt; from torchfx.effect import Normalize, RMSNormalizationStrategy</span>
<span class="sd">&gt;&gt;&gt; normalize = fx.Normalize(peak=0.8, strategy=RMSNormalizationStrategy())</span>
<span class="sd">&gt;&gt;&gt; result = wave | normalize</span>

<span class="sd">BPM-synced delay with automatic sample rate configuration:</span>

<span class="sd">&gt;&gt;&gt; # fs is automatically inferred from Wave object</span>
<span class="sd">&gt;&gt;&gt; delay = fx.Delay(bpm=120, delay_time=&quot;1/4d&quot;, feedback=0.5, mix=0.3)</span>
<span class="sd">&gt;&gt;&gt; result = wave | delay</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">For comprehensive guidance on creating custom effects, including parameter</span>
<span class="sd">handling, the strategy pattern, and multi-channel processing, see the</span>
<span class="sd">wiki page &quot;3.5 Creating Custom Effects&quot;. For API reference and detailed</span>
<span class="sd">parameter specifications, see &quot;8.2 torchfx.FX and Effects&quot;.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">.. [1] Creating Custom Effects: wiki/3.5 Creating Custom Effects.md</span>
<span class="sd">.. [2] API Reference: wiki/8.2 torchfx.FX and Effects.md</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">nn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchaudio</span><span class="w"> </span><span class="kn">import</span> <span class="n">functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">override</span>


<div class="viewcode-block" id="FX">
<a class="viewcode-back" href="../../api/core.html#torchfx.FX">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FX</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for all audio effects and filters.</span>

<span class="sd">    FX serves as the foundation for all effects in torchfx, combining PyTorch&#39;s</span>
<span class="sd">    nn.Module with abstract base class requirements. This design ensures effects</span>
<span class="sd">    are compatible with PyTorch&#39;s module system while enforcing a consistent</span>
<span class="sd">    interface across all effect implementations.</span>

<span class="sd">    All effects must implement the abstract __init__ and forward methods. The</span>
<span class="sd">    forward method receives audio tensors of shape (..., time) and returns</span>
<span class="sd">    processed tensors.</span>

<span class="sd">    Inheriting from nn.Module provides:</span>
<span class="sd">    - GPU/CPU device management (.to(), .cuda(), .cpu())</span>
<span class="sd">    - Parameter and buffer registration</span>
<span class="sd">    - Integration with nn.Sequential for effect chaining</span>
<span class="sd">    - Serialization support (state_dict, load_state_dict)</span>
<span class="sd">    - Gradient computation (when not using @torch.no_grad())</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args : tuple</span>
<span class="sd">        Positional arguments passed to nn.Module.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Keyword arguments passed to nn.Module.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    forward(x: Tensor) -&gt; Tensor</span>
<span class="sd">        Process input tensor and return transformed output. Must be implemented</span>
<span class="sd">        by all subclasses.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When creating custom effects:</span>

<span class="sd">    1. Always call super().__init__() in your constructor</span>
<span class="sd">    2. Implement forward() to process tensors of shape (..., time)</span>
<span class="sd">    3. Use @torch.no_grad() decorator for inference-only effects</span>
<span class="sd">    4. Validate parameters in __init__ using assertions</span>
<span class="sd">    5. For sample-rate dependent effects, accept optional fs parameter</span>

<span class="sd">    The FX base class uses the strategy pattern for extensibility. Effects</span>
<span class="sd">    can accept strategy objects to customize processing behavior without</span>
<span class="sd">    modifying the core effect implementation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Gain : Volume adjustment effect</span>
<span class="sd">    Normalize : Amplitude normalization effect</span>
<span class="sd">    Reverb : Reverb effect using feedback delay network</span>
<span class="sd">    Delay : Multi-tap delay effect with BPM synchronization</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a simple custom effect:</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from torchfx.effect import FX</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class SimpleGain(FX):</span>
<span class="sd">    ...     def __init__(self, gain: float) -&gt; None:</span>
<span class="sd">    ...         super().__init__()</span>
<span class="sd">    ...         assert gain &gt; 0, &quot;Gain must be positive&quot;</span>
<span class="sd">    ...         self.gain = gain</span>
<span class="sd">    ...</span>
<span class="sd">    ...     @torch.no_grad()</span>
<span class="sd">    ...     def forward(self, waveform: torch.Tensor) -&gt; torch.Tensor:</span>
<span class="sd">    ...         return waveform * self.gain</span>

<span class="sd">    Use in a pipeline:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; effect = SimpleGain(0.5)</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | effect</span>

<span class="sd">    Chain multiple effects:</span>

<span class="sd">    &gt;&gt;&gt; result = wave | SimpleGain(0.5) | fx.Normalize(peak=1.0)</span>

<span class="sd">    Create effects with strategies:</span>

<span class="sd">    &gt;&gt;&gt; from abc import ABC, abstractmethod</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class ProcessingStrategy(ABC):</span>
<span class="sd">    ...     @abstractmethod</span>
<span class="sd">    ...     def __call__(self, waveform: torch.Tensor) -&gt; torch.Tensor:</span>
<span class="sd">    ...         pass</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class StrategyEffect(FX):</span>
<span class="sd">    ...     def __init__(self, strategy: ProcessingStrategy) -&gt; None:</span>
<span class="sd">    ...         super().__init__()</span>
<span class="sd">    ...         self.strategy = strategy</span>
<span class="sd">    ...</span>
<span class="sd">    ...     def forward(self, waveform: torch.Tensor) -&gt; torch.Tensor:</span>
<span class="sd">    ...         return self.strategy(waveform)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    For detailed examples of custom effect creation, including multi-channel</span>
<span class="sd">    processing and the strategy pattern, see the &quot;Creating Custom Effects&quot;</span>
<span class="sd">    wiki page.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="FX.forward">
<a class="viewcode-back" href="../../api/core.html#torchfx.FX.forward">[docs]</a>
    <span class="nd">@override</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span> <span class="o">...</span></div>
</div>



<div class="viewcode-block" id="Gain">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Gain">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Gain</span><span class="p">(</span><span class="n">FX</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adjust volume of audio waveforms with multiple gain modes and optional clamping.</span>

<span class="sd">    The Gain effect modifies waveform amplitude using three different gain</span>
<span class="sd">    representations: direct amplitude multiplication, decibel (dB) adjustment,</span>
<span class="sd">    or power scaling. An optional clamping parameter prevents clipping artifacts</span>
<span class="sd">    by limiting output values to [-1.0, 1.0].</span>

<span class="sd">    This effect extends torchaudio.transforms.Vol by adding the clamp parameter</span>
<span class="sd">    for better control over output dynamic range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gain : float</span>
<span class="sd">        The gain factor to apply to the waveform. Must be positive for</span>
<span class="sd">        &quot;amplitude&quot; and &quot;power&quot; gain types. Can be negative for &quot;db&quot; type.</span>
<span class="sd">    gain_type : str, optional</span>
<span class="sd">        The type of gain to apply. Default is &quot;amplitude&quot;.</span>

<span class="sd">        - &quot;amplitude&quot;: Direct multiplication by gain factor</span>
<span class="sd">        - &quot;db&quot;: Decibel-based gain using torchaudio.functional.gain</span>
<span class="sd">        - &quot;power&quot;: Power-based gain converted to dB internally</span>
<span class="sd">    clamp : bool, optional</span>
<span class="sd">        If True, clamps the output waveform to the range [-1.0, 1.0] to</span>
<span class="sd">        prevent clipping. Default is False.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If gain is negative when gain_type is &quot;amplitude&quot; or &quot;power&quot;.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    torchaudio.transforms.Vol : Original transform this effect is based on</span>
<span class="sd">    Normalize : Amplitude normalization with multiple strategies</span>
<span class="sd">    torchaudio.functional.gain : Function used for dB and power gain</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    **Gain Type Formulas:**</span>

<span class="sd">    - Amplitude: :math:`y[n] = x[n] \cdot \text{gain}`</span>
<span class="sd">    - Decibel: :math:`y[n] = x[n] \cdot 10^{\text{gain}/20}`</span>
<span class="sd">    - Power: :math:`y[n] = x[n] \cdot 10^{(10 \log_{10}(\text{gain}))/20}`</span>

<span class="sd">    **Clamping:**</span>

<span class="sd">    When clamp=True, the final output is constrained:</span>
<span class="sd">    :math:`y[n] = \text{clip}(y[n], -1.0, 1.0)`</span>

<span class="sd">    The @torch.no_grad() decorator disables gradient computation for efficiency</span>
<span class="sd">    during inference-only operations.</span>

<span class="sd">    This class is based on torchaudio.transforms.Vol, licensed under the</span>
<span class="sd">    BSD 2-Clause License. See licenses.torchaudio.BSD-2-Clause.txt for details.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic amplitude gain to double volume:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; gain = fx.Gain(gain=2.0, gain_type=&quot;amplitude&quot;)</span>
<span class="sd">    &gt;&gt;&gt; louder = wave | gain</span>

<span class="sd">    Increase volume by 6 dB with clamping:</span>

<span class="sd">    &gt;&gt;&gt; gain = fx.Gain(gain=6.0, gain_type=&quot;db&quot;, clamp=True)</span>
<span class="sd">    &gt;&gt;&gt; louder = wave | gain</span>

<span class="sd">    Increase power by 4x (equivalent to +6 dB or 2x amplitude):</span>

<span class="sd">    &gt;&gt;&gt; gain = fx.Gain(gain=4.0, gain_type=&quot;power&quot;)</span>
<span class="sd">    &gt;&gt;&gt; louder = wave | gain</span>

<span class="sd">    Reduce volume by 50% without clamping:</span>

<span class="sd">    &gt;&gt;&gt; gain = fx.Gain(gain=0.5, gain_type=&quot;amplitude&quot;)</span>
<span class="sd">    &gt;&gt;&gt; quieter = wave | gain</span>

<span class="sd">    Direct tensor processing:</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; waveform = torch.randn(2, 44100)  # (channels, samples)</span>
<span class="sd">    &gt;&gt;&gt; gain = fx.Gain(gain=0.5, gain_type=&quot;amplitude&quot;, clamp=True)</span>
<span class="sd">    &gt;&gt;&gt; quieter = gain(waveform)</span>

<span class="sd">    Negative dB for attenuation:</span>

<span class="sd">    &gt;&gt;&gt; gain = fx.Gain(gain=-3.0, gain_type=&quot;db&quot;)</span>
<span class="sd">    &gt;&gt;&gt; quieter = wave | gain</span>

<span class="sd">    Chain with other effects:</span>

<span class="sd">    &gt;&gt;&gt; processed = wave | fx.Gain(2.0) | fx.Normalize(peak=0.8)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">gain_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;amplitude&quot;</span><span class="p">,</span> <span class="n">clamp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain</span> <span class="o">=</span> <span class="n">gain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_type</span> <span class="o">=</span> <span class="n">gain_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clamp</span> <span class="o">=</span> <span class="n">clamp</span>

        <span class="k">if</span> <span class="n">gain_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;amplitude&quot;</span><span class="p">,</span> <span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">gain</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If gain_type = amplitude or power, gain must be positive.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Gain.forward">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Gain.forward">[docs]</a>
    <span class="nd">@override</span>
    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            waveform (Tensor): Tensor of audio of dimension `(..., time)`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor: Tensor of audio of dimension `(..., time)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain_type</span> <span class="o">==</span> <span class="s2">&quot;amplitude&quot;</span><span class="p">:</span>
            <span class="n">waveform</span> <span class="o">=</span> <span class="n">waveform</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain_type</span> <span class="o">==</span> <span class="s2">&quot;db&quot;</span><span class="p">:</span>
            <span class="n">waveform</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gain</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gain_type</span> <span class="o">==</span> <span class="s2">&quot;power&quot;</span><span class="p">:</span>
            <span class="n">waveform</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gain</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clamp</span><span class="p">:</span>
            <span class="n">waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">waveform</span></div>
</div>



<div class="viewcode-block" id="Normalize">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Normalize">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Normalize</span><span class="p">(</span><span class="n">FX</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalize waveform amplitude to a target peak value using pluggable strategies.</span>

<span class="sd">    The Normalize effect adjusts waveform amplitude to achieve a specified peak value</span>
<span class="sd">    using different normalization algorithms. The normalization strategy can be</span>
<span class="sd">    selected from built-in options (peak, RMS, percentile, per-channel) or provided</span>
<span class="sd">    as a custom callable function.</span>

<span class="sd">    This effect uses the strategy pattern to support multiple normalization algorithms</span>
<span class="sd">    while maintaining a clean interface. If no strategy is specified, peak normalization</span>
<span class="sd">    is used by default.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peak : float, optional</span>
<span class="sd">        The target peak value to normalize to. Must be positive. Default is 1.0.</span>
<span class="sd">    strategy : NormalizationStrategy or Callable[[Tensor, float], Tensor] or None, optional</span>
<span class="sd">        The normalization strategy to use. Can be:</span>

<span class="sd">        - None (default): Uses PeakNormalizationStrategy</span>
<span class="sd">        - NormalizationStrategy instance: Uses the specified strategy</span>
<span class="sd">        - Callable: Custom function wrapped in CustomNormalizationStrategy</span>

<span class="sd">        Built-in strategies:</span>

<span class="sd">        - PeakNormalizationStrategy: Normalize to absolute maximum value</span>
<span class="sd">        - RMSNormalizationStrategy: Normalize to RMS energy level</span>
<span class="sd">        - PercentileNormalizationStrategy: Normalize to a percentile threshold</span>
<span class="sd">        - PerChannelNormalizationStrategy: Normalize each channel independently</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If peak is not positive.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If strategy is not an instance of NormalizationStrategy.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    PeakNormalizationStrategy : Normalize to absolute maximum value</span>
<span class="sd">    RMSNormalizationStrategy : Normalize to RMS energy</span>
<span class="sd">    PercentileNormalizationStrategy : Normalize to percentile threshold</span>
<span class="sd">    PerChannelNormalizationStrategy : Independent per-channel normalization</span>
<span class="sd">    CustomNormalizationStrategy : Wrapper for custom normalization functions</span>
<span class="sd">    Gain : Volume adjustment with multiple gain modes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    **Strategy Pattern:**</span>

<span class="sd">    The Normalize effect delegates processing to a strategy object, allowing</span>
<span class="sd">    different normalization algorithms to be used without modifying the core</span>
<span class="sd">    effect implementation. This design pattern promotes extensibility and</span>
<span class="sd">    clean separation of concerns.</span>

<span class="sd">    **Automatic Strategy Wrapping:**</span>

<span class="sd">    If a callable function is passed as the strategy parameter, it is</span>
<span class="sd">    automatically wrapped in a CustomNormalizationStrategy instance. The</span>
<span class="sd">    function must have the signature: ``func(waveform: Tensor, peak: float) -&gt; Tensor``</span>

<span class="sd">    **Processing with @torch.no_grad():**</span>

<span class="sd">    The forward method is decorated with @torch.no_grad() for efficient</span>
<span class="sd">    inference-only operation. If gradients are needed for training, subclass</span>
<span class="sd">    this effect and remove the decorator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic peak normalization to default peak of 1.0:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize()</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    Normalize to a specific peak value:</span>

<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.8)</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    Use RMS normalization strategy:</span>

<span class="sd">    &gt;&gt;&gt; from torchfx.effect import RMSNormalizationStrategy</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.7, strategy=RMSNormalizationStrategy())</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    Use percentile normalization (99th percentile):</span>

<span class="sd">    &gt;&gt;&gt; from torchfx.effect import PercentileNormalizationStrategy</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=1.0, strategy=PercentileNormalizationStrategy(percentile=99.0))</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    Per-channel normalization for stereo audio:</span>

<span class="sd">    &gt;&gt;&gt; from torchfx.effect import PerChannelNormalizationStrategy</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.9, strategy=PerChannelNormalizationStrategy())</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    Custom normalization with a callable function:</span>

<span class="sd">    &gt;&gt;&gt; def custom_normalize(waveform, peak):</span>
<span class="sd">    ...     # Normalize based on standard deviation</span>
<span class="sd">    ...     std = waveform.std()</span>
<span class="sd">    ...     return (waveform / std * peak) if std &gt; 0 else waveform</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.8, strategy=custom_normalize)</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    Direct tensor processing:</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; waveform = torch.randn(2, 44100)  # (channels, samples)</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.5)</span>
<span class="sd">    &gt;&gt;&gt; normalized = normalize(waveform)</span>

<span class="sd">    Chain with other effects:</span>

<span class="sd">    &gt;&gt;&gt; result = wave | fx.Gain(2.0) | fx.Normalize(peak=0.8)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    For detailed information about creating custom normalization strategies and</span>
<span class="sd">    the strategy pattern, see wiki page &quot;3.5 Creating Custom Effects&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">peak</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">strategy</span><span class="p">:</span> <span class="n">NormalizationStrategy</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">peak</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Peak value must be positive.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak</span> <span class="o">=</span> <span class="n">peak</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">strategy</span><span class="p">):</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">CustomNormalizationStrategy</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span> <span class="ow">or</span> <span class="n">PeakNormalizationStrategy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> <span class="n">NormalizationStrategy</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Strategy must be an instance of NormalizationStrategy.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Normalize.forward">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Normalize.forward">[docs]</a>
    <span class="nd">@override</span>
    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="NormalizationStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.NormalizationStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NormalizationStrategy</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for normalization strategies.</span>

<span class="sd">    NormalizationStrategy defines the interface for all normalization algorithms</span>
<span class="sd">    used by the Normalize effect. Concrete implementations must implement the</span>
<span class="sd">    __call__ method to provide specific normalization logic.</span>

<span class="sd">    This class is part of the strategy pattern implementation, allowing the</span>
<span class="sd">    Normalize effect to support multiple normalization algorithms without</span>
<span class="sd">    modifying its core implementation.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__(waveform: Tensor, peak: float) -&gt; Tensor</span>
<span class="sd">        Normalize the waveform to the given peak value using the strategy&#39;s</span>
<span class="sd">        specific algorithm.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Normalize : The effect that uses normalization strategies</span>
<span class="sd">    PeakNormalizationStrategy : Normalize to absolute maximum value</span>
<span class="sd">    RMSNormalizationStrategy : Normalize to RMS energy</span>
<span class="sd">    PercentileNormalizationStrategy : Normalize to percentile threshold</span>
<span class="sd">    PerChannelNormalizationStrategy : Independent per-channel normalization</span>
<span class="sd">    CustomNormalizationStrategy : Wrapper for custom functions</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When implementing a custom normalization strategy, ensure that:</span>

<span class="sd">    1. The __call__ method handles edge cases (e.g., silent audio)</span>
<span class="sd">    2. The returned tensor has the same shape and dtype as the input</span>
<span class="sd">    3. The strategy preserves the device of the input tensor</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Implement a custom normalization strategy:</span>

<span class="sd">    &gt;&gt;&gt; from torchfx.effect import NormalizationStrategy</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class MedianNormalizationStrategy(NormalizationStrategy):</span>
<span class="sd">    ...     def __call__(self, waveform: torch.Tensor, peak: float) -&gt; torch.Tensor:</span>
<span class="sd">    ...         median = torch.median(torch.abs(waveform))</span>
<span class="sd">    ...         return waveform / median * peak if median &gt; 0 else waveform</span>

<span class="sd">    Use the custom strategy:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.8, strategy=MedianNormalizationStrategy())</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    For more information about the strategy pattern and creating custom</span>
<span class="sd">    strategies, see wiki page &quot;3.5 Creating Custom Effects&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NormalizationStrategy.__call__">
<a class="viewcode-back" href="../../api/effects.html#torchfx.NormalizationStrategy.__call__">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">peak</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize the waveform to the given peak value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waveform : Tensor</span>
<span class="sd">            Input audio tensor of shape (..., time).</span>
<span class="sd">        peak : float</span>
<span class="sd">            Target peak value for normalization.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor</span>
<span class="sd">            Normalized waveform with same shape and dtype as input.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="CustomNormalizationStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.CustomNormalizationStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomNormalizationStrategy</span><span class="p">(</span><span class="n">NormalizationStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalization using a custom user-provided function.</span>

<span class="sd">    This strategy wraps a user-provided callable function to make it compatible</span>
<span class="sd">    with the NormalizationStrategy interface. It is automatically used when a</span>
<span class="sd">    callable is passed to the Normalize effect&#39;s strategy parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : Callable[[Tensor, float], Tensor]</span>
<span class="sd">        Custom normalization function with signature:</span>
<span class="sd">        func(waveform: Tensor, peak: float) -&gt; Tensor</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If func is not callable.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Normalize : Effect that uses this strategy wrapper</span>
<span class="sd">    NormalizationStrategy : Abstract base class for strategies</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The custom function must:</span>

<span class="sd">    - Accept two parameters: waveform (Tensor) and peak (float)</span>
<span class="sd">    - Return a normalized Tensor with the same shape and dtype as input</span>
<span class="sd">    - Preserve the device of the input tensor</span>
<span class="sd">    - Handle edge cases (e.g., silent audio with all zeros)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define a custom normalization function:</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; def std_normalize(waveform, peak):</span>
<span class="sd">    ...     std = waveform.std()</span>
<span class="sd">    ...     return (waveform / std * peak) if std &gt; 0 else waveform</span>

<span class="sd">    Use directly with Normalize (automatically wrapped):</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.8, strategy=std_normalize)</span>
<span class="sd">    &gt;&gt;&gt; normalized = wave | normalize</span>

<span class="sd">    Or explicitly instantiate the strategy:</span>

<span class="sd">    &gt;&gt;&gt; from torchfx.effect import CustomNormalizationStrategy</span>
<span class="sd">    &gt;&gt;&gt; strategy = CustomNormalizationStrategy(std_normalize)</span>
<span class="sd">    &gt;&gt;&gt; normalize = fx.Normalize(peak=0.8, strategy=strategy)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="s2">&quot;func must be callable&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">peak</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">peak</span><span class="p">)</span></div>



<div class="viewcode-block" id="PeakNormalizationStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.PeakNormalizationStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PeakNormalizationStrategy</span><span class="p">(</span><span class="n">NormalizationStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalization to the absolute peak value.</span>

<span class="sd">    .. math::</span>
<span class="sd">        y[n] =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \frac{x[n]}{max(|x[n]|)} \cdot peak, &amp; \text{if } max(|x[n]|) &gt; 0 \\</span>
<span class="sd">            x[n], &amp; \text{otherwise}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where:</span>
<span class="sd">        - :math:`x[n]` is the input signal,</span>
<span class="sd">        - :math:`y[n]` is the output signal,</span>
<span class="sd">        - :math:`peak` is the target peak value.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">peak</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">waveform</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">waveform</span> <span class="o">/</span> <span class="n">max_val</span> <span class="o">*</span> <span class="n">peak</span> <span class="k">if</span> <span class="n">max_val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">waveform</span></div>



<div class="viewcode-block" id="RMSNormalizationStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.RMSNormalizationStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RMSNormalizationStrategy</span><span class="p">(</span><span class="n">NormalizationStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalization to Root Mean Square (RMS) energy.</span>

<span class="sd">    .. math::</span>
<span class="sd">        y[n] =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \frac{x[n]}{RMS(x[n])} \cdot peak, &amp; \text{if } RMS(x[n]) &gt; 0 \\</span>
<span class="sd">            x[n], &amp; \text{otherwise}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where:</span>
<span class="sd">        - :math:`x[n]` is the input signal,</span>
<span class="sd">        - :math:`y[n]` is the output signal,</span>
<span class="sd">        - :math:`RMS(x[n])` is the root mean square of the signal,</span>
<span class="sd">        - :math:`peak` is the target peak value.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">peak</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="n">rms</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">waveform</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">waveform</span> <span class="o">/</span> <span class="n">rms</span> <span class="o">*</span> <span class="n">peak</span> <span class="k">if</span> <span class="n">rms</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">waveform</span></div>



<div class="viewcode-block" id="PercentileNormalizationStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.PercentileNormalizationStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PercentileNormalizationStrategy</span><span class="p">(</span><span class="n">NormalizationStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalization using a percentile of absolute values.</span>

<span class="sd">    .. math::</span>
<span class="sd">        y[n] =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \frac{x[n]}{P_p(|x[n]|)} \cdot peak, &amp; \text{if } P_p(|x[n]|) &gt; 0 \\</span>
<span class="sd">            x[n], &amp; \text{otherwise}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where:</span>
<span class="sd">        - :math:`x[n]` is the input signal,</span>
<span class="sd">        - :math:`y[n]` is the output signal,</span>
<span class="sd">        - :math:`P_p(|x[n]|)` is the p-th percentile of the absolute values of the signal,</span>
<span class="sd">        - :math:`peak` is the target peak value,</span>
<span class="sd">        - :math:`p` is the specified percentile (:math:`0 &lt; p \leqslant 100`).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    percentile : float</span>
<span class="sd">        The percentile :math:`p` to use for normalization (:math:`0 &lt; p \leqslant 100`). Default is 99.0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">99.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">percentile</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">,</span> <span class="s2">&quot;Percentile must be between 0 and 100.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">peak</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="n">abs_waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">waveform</span><span class="p">)</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">abs_waveform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">waveform</span> <span class="o">/</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">peak</span> <span class="k">if</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">waveform</span></div>



<div class="viewcode-block" id="PerChannelNormalizationStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.PerChannelNormalizationStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PerChannelNormalizationStrategy</span><span class="p">(</span><span class="n">NormalizationStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalize each channel independently to its own peak.</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_c[n] =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \frac{x_c[n]}{max(|x_c[n]|)} \cdot peak, &amp; \text{if } max(|x_c[n]|) &gt; 0 \\</span>
<span class="sd">            x_c[n], &amp; \text{otherwise}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where:</span>
<span class="sd">        - :math:`x_c[n]` is the input signal for channel c,</span>
<span class="sd">        - :math:`y_c[n]` is the output signal for channel c,</span>
<span class="sd">        - :math:`peak` is the target peak value.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">peak</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Waveform must have at least 2 dimensions (channels, time).&quot;</span>

        <span class="c1"># waveform: (channels, time) or (batch, channels, time)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">max_per_channel</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">waveform</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_per_channel</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">waveform</span> <span class="o">/</span> <span class="n">max_per_channel</span> <span class="o">*</span> <span class="n">peak</span><span class="p">,</span> <span class="n">waveform</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dims</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">max_per_channel</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">waveform</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_per_channel</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">waveform</span> <span class="o">/</span> <span class="n">max_per_channel</span> <span class="o">*</span> <span class="n">peak</span><span class="p">,</span> <span class="n">waveform</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Waveform must have shape (C, T) or (B, C, T)&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="Reverb">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Reverb">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Reverb</span><span class="p">(</span><span class="n">FX</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply reverb effect using a feedback delay network for spatial ambiance.</span>

<span class="sd">    The Reverb effect creates spatial ambiance by simulating sound reflections</span>
<span class="sd">    in an acoustic space. It uses a simple feedback comb filter (feedback delay</span>
<span class="sd">    network) to produce reverb-like effects with controllable decay time and</span>
<span class="sd">    wet/dry mix.</span>

<span class="sd">    This is a basic reverb implementation suitable for adding spatial depth to</span>
<span class="sd">    audio signals. For more complex reverb algorithms, consider using convolution</span>
<span class="sd">    reverbs with impulse responses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    delay : int, optional</span>
<span class="sd">        Delay time in samples for the feedback comb filter. Determines the</span>
<span class="sd">        apparent size of the simulated space. Default is 4410 samples, which</span>
<span class="sd">        corresponds to approximately 100ms at 44.1kHz sample rate.</span>
<span class="sd">    decay : float, optional</span>
<span class="sd">        Feedback decay factor controlling how quickly the reverb tail fades.</span>
<span class="sd">        Must be in the range (0, 1). Higher values create longer reverb tails.</span>
<span class="sd">        Default is 0.5.</span>
<span class="sd">    mix : float, optional</span>
<span class="sd">        Wet/dry mix controlling the balance between processed (wet) and</span>
<span class="sd">        original (dry) signals. Range is [0, 1] where:</span>

<span class="sd">        - 0.0 = fully dry (no reverb)</span>
<span class="sd">        - 1.0 = fully wet (only reverb)</span>
<span class="sd">        - 0.5 = equal mix</span>

<span class="sd">        Default is 0.5.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If delay is not positive, decay is not in (0, 1), or mix is not in [0, 1].</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Delay : Multi-tap delay effect with BPM synchronization</span>
<span class="sd">    Gain : Volume adjustment effect</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    **Algorithm:**</span>

<span class="sd">    The reverb is computed using a feedback comb filter:</span>

<span class="sd">    .. math::</span>

<span class="sd">        y[n] = (1 - mix) \cdot x[n] + mix \cdot (x[n] + decay \cdot x[n - delay])</span>

<span class="sd">    where:</span>
<span class="sd">        - :math:`x[n]` is the input signal</span>
<span class="sd">        - :math:`y[n]` is the output signal</span>
<span class="sd">        - :math:`delay` is the delay time in samples</span>
<span class="sd">        - :math:`decay` is the feedback decay factor</span>
<span class="sd">        - :math:`mix` is the wet/dry mix parameter</span>

<span class="sd">    **Processing Details:**</span>

<span class="sd">    - If the input waveform is shorter than the delay time, the input is returned</span>
<span class="sd">      unchanged.</span>
<span class="sd">    - The effect processes tensors of arbitrary shape (..., time).</span>
<span class="sd">    - Uses @torch.no_grad() decorator for efficient inference-only operation.</span>
<span class="sd">    - Padding is applied using torch.nn.functional.pad for the delay buffer.</span>

<span class="sd">    **Delay Time Calculation:**</span>

<span class="sd">    To convert time in milliseconds to samples:</span>

<span class="sd">    .. math::</span>

<span class="sd">        delay_{samples} = \frac{time_{ms}}{1000} \cdot sample\_rate</span>

<span class="sd">    For example, at 44.1kHz:</span>
<span class="sd">        - 50ms = 2205 samples</span>
<span class="sd">        - 100ms = 4410 samples (default)</span>
<span class="sd">        - 200ms = 8820 samples</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic reverb with default parameters:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; reverb = fx.Reverb()</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | reverb</span>

<span class="sd">    Short room reverb (50ms delay):</span>

<span class="sd">    &gt;&gt;&gt; reverb = fx.Reverb(delay=2205, decay=0.4, mix=0.3)</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | reverb</span>

<span class="sd">    Long hall reverb (200ms delay):</span>

<span class="sd">    &gt;&gt;&gt; reverb = fx.Reverb(delay=8820, decay=0.7, mix=0.4)</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | reverb</span>

<span class="sd">    Subtle reverb with low mix:</span>

<span class="sd">    &gt;&gt;&gt; reverb = fx.Reverb(delay=4410, decay=0.5, mix=0.2)</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | reverb</span>

<span class="sd">    Direct tensor processing:</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; waveform = torch.randn(2, 44100)  # (channels, samples)</span>
<span class="sd">    &gt;&gt;&gt; reverb = fx.Reverb(delay=4410, decay=0.6, mix=0.3)</span>
<span class="sd">    &gt;&gt;&gt; reverberated = reverb(waveform)</span>

<span class="sd">    Chain with other effects:</span>

<span class="sd">    &gt;&gt;&gt; processed = wave | fx.Gain(0.8) | fx.Reverb(delay=4410, decay=0.5, mix=0.3)</span>

<span class="sd">    GPU processing:</span>

<span class="sd">    &gt;&gt;&gt; wave = wave.to(&quot;cuda&quot;)</span>
<span class="sd">    &gt;&gt;&gt; reverb = fx.Reverb(delay=4410, decay=0.6, mix=0.3).to(&quot;cuda&quot;)</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | reverb</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4410</span><span class="p">,</span> <span class="n">decay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">mix</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Delay must be positive.&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">decay</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Decay must be between 0 and 1.&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">mix</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Mix must be between 0 and 1.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mix</span> <span class="o">=</span> <span class="n">mix</span>

<div class="viewcode-block" id="Reverb.forward">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Reverb.forward">[docs]</a>
    <span class="nd">@override</span>
    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="c1"># waveform: (..., time)</span>
        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveform</span>

        <span class="c1"># Pad waveform for delay</span>
        <span class="n">padded</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Create delayed signal</span>
        <span class="n">delayed</span> <span class="o">=</span> <span class="n">padded</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">delay</span><span class="p">]</span>
        <span class="c1"># Feedback comb filter</span>
        <span class="n">reverb_signal</span> <span class="o">=</span> <span class="n">waveform</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay</span> <span class="o">*</span> <span class="n">delayed</span>
        <span class="c1"># Wet/dry mix</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">waveform</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mix</span> <span class="o">*</span> <span class="n">reverb_signal</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>



<div class="viewcode-block" id="DelayStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.DelayStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayStrategy</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for delay processing strategies.</span>

<span class="sd">    DelayStrategy defines the interface for different delay processing behaviors</span>
<span class="sd">    used by the Delay effect. Concrete implementations provide specific delay</span>
<span class="sd">    algorithms such as mono delay (uniform across all channels) or ping-pong</span>
<span class="sd">    delay (alternating between stereo channels).</span>

<span class="sd">    This class is part of the strategy pattern implementation, allowing the</span>
<span class="sd">    Delay effect to support multiple processing behaviors without modifying</span>
<span class="sd">    its core implementation.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    apply_delay(waveform, delay_samples, taps, feedback) -&gt; Tensor</span>
<span class="sd">        Apply the delay effect to the waveform using the strategy&#39;s specific</span>
<span class="sd">        algorithm.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Delay : The effect that uses delay strategies</span>
<span class="sd">    MonoDelayStrategy : Uniform delay for all channels</span>
<span class="sd">    PingPongDelayStrategy : Alternating stereo delay</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When implementing a custom delay strategy:</span>

<span class="sd">    1. The output length should be extended to accommodate all delayed taps:</span>
<span class="sd">       ``output_length = input_length + (delay_samples * taps)``</span>
<span class="sd">    2. The first tap always has amplitude 1.0, subsequent taps use feedback</span>
<span class="sd">       scaling: ``feedback^(tap-1)``</span>
<span class="sd">    3. The returned tensor should preserve the device and dtype of the input</span>
<span class="sd">    4. Handle different tensor dimensions: 1D (mono), 2D (multi-channel),</span>
<span class="sd">       and higher dimensions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Implement a custom delay strategy:</span>

<span class="sd">    &gt;&gt;&gt; from torchfx.effect import DelayStrategy</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class CrossChannelDelayStrategy(DelayStrategy):</span>
<span class="sd">    ...     &#39;&#39;&#39;Apply delay from each channel to all other channels.&#39;&#39;&#39;</span>
<span class="sd">    ...     def apply_delay(self, waveform, delay_samples, taps, feedback):</span>
<span class="sd">    ...         # Custom cross-channel delay logic</span>
<span class="sd">    ...         original_length = waveform.size(-1)</span>
<span class="sd">    ...         output_length = original_length + delay_samples * taps</span>
<span class="sd">    ...         # ... implementation ...</span>
<span class="sd">    ...         return delayed_waveform</span>

<span class="sd">    Use with Delay effect:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.Delay(delay_samples=2205, taps=3, feedback=0.4, mix=0.3,</span>
<span class="sd">    ...                  strategy=CrossChannelDelayStrategy())</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | delay</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    For more information about the strategy pattern and creating custom</span>
<span class="sd">    strategies, see wiki page &quot;3.5 Creating Custom Effects&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DelayStrategy.apply_delay">
<a class="viewcode-back" href="../../api/effects.html#torchfx.DelayStrategy.apply_delay">[docs]</a>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_delay</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">delay_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">taps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">feedback</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply delay processing to the waveform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waveform : Tensor</span>
<span class="sd">            Input audio tensor of shape (..., time) or (channels, time).</span>
<span class="sd">        delay_samples : int</span>
<span class="sd">            Delay time in samples for each tap.</span>
<span class="sd">        taps : int</span>
<span class="sd">            Number of delay taps (echoes). Each tap is delayed by</span>
<span class="sd">            delay_samples * tap_number.</span>
<span class="sd">        feedback : float</span>
<span class="sd">            Feedback amount in range [0, 0.95]. Controls the amplitude of</span>
<span class="sd">            taps 2 and beyond. First tap always has amplitude 1.0, subsequent</span>
<span class="sd">            taps use feedback^(tap-1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor</span>
<span class="sd">            Delayed audio with extended length to accommodate all taps.</span>
<span class="sd">            Output length is: input_length + (delay_samples * taps).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="MonoDelayStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.MonoDelayStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MonoDelayStrategy</span><span class="p">(</span><span class="n">DelayStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply uniform delay to all channels with multiple taps and feedback.</span>

<span class="sd">    MonoDelayStrategy applies the same delay pattern to all audio channels,</span>
<span class="sd">    creating identical echoes across the stereo field. This is the default</span>
<span class="sd">    delay strategy used by the Delay effect.</span>

<span class="sd">    The strategy creates multiple delay taps (echoes), each delayed by an</span>
<span class="sd">    integer multiple of the base delay time. The first tap has full amplitude,</span>
<span class="sd">    and subsequent taps decay exponentially based on the feedback parameter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DelayStrategy : Abstract base class for delay strategies</span>
<span class="sd">    PingPongDelayStrategy : Alternating stereo delay</span>
<span class="sd">    Delay : The effect that uses this strategy</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    **Output Length:**</span>

<span class="sd">    The output is extended to accommodate all delayed taps:</span>
<span class="sd">    ``output_length = input_length + (delay_samples * taps)``</span>

<span class="sd">    **Tap Amplitude:**</span>

<span class="sd">    - Tap 1: amplitude = 1.0</span>
<span class="sd">    - Tap n (n &gt; 1): amplitude = feedback^(n-1)</span>

<span class="sd">    **Multi-dimensional Support:**</span>

<span class="sd">    The strategy handles tensors of various shapes:</span>

<span class="sd">    - 1D: (time,) - Mono audio</span>
<span class="sd">    - 2D: (channels, time) - Multi-channel audio</span>
<span class="sd">    - Higher dimensions: (..., time) - Batched or complex audio</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use mono delay strategy explicitly:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; from torchfx.effect import MonoDelayStrategy</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.Delay(delay_samples=2205, taps=4, feedback=0.5, mix=0.3,</span>
<span class="sd">    ...                  strategy=MonoDelayStrategy())</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | delay</span>

<span class="sd">    MonoDelayStrategy is the default, so this is equivalent:</span>

<span class="sd">    &gt;&gt;&gt; delay = fx.Delay(delay_samples=2205, taps=4, feedback=0.5, mix=0.3)</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | delay</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MonoDelayStrategy.apply_delay">
<a class="viewcode-back" href="../../api/effects.html#torchfx.MonoDelayStrategy.apply_delay">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_delay</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">delay_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">taps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">feedback</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply mono delay with multiple taps and feedback.</span>

<span class="sd">        Output length is extended to accommodate all delayed taps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waveform : Tensor</span>
<span class="sd">            Input audio tensor of shape (time,), (channels, time), or (..., time).</span>
<span class="sd">        delay_samples : int</span>
<span class="sd">            Delay time in samples for each tap.</span>
<span class="sd">        taps : int</span>
<span class="sd">            Number of delay taps (echoes).</span>
<span class="sd">        feedback : float</span>
<span class="sd">            Feedback amount for taps 2 and beyond.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor</span>
<span class="sd">            Delayed audio with shape matching input except extended time dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate required output length</span>
        <span class="n">original_length</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">max_delay_samples</span> <span class="o">=</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="n">taps</span>
        <span class="n">output_length</span> <span class="o">=</span> <span class="n">original_length</span> <span class="o">+</span> <span class="n">max_delay_samples</span>

        <span class="c1"># waveform shape: (..., time) or (channels, time)</span>
        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Single channel: (time,)</span>
            <span class="n">delayed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">output_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tap</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">taps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tap_delay</span> <span class="o">=</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="n">tap</span>
                <span class="c1"># First tap always has amplitude 1.0, subsequent taps use feedback</span>
                <span class="c1"># Copy original signal starting</span>
                <span class="n">feedback_amt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">tap</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">feedback</span> <span class="o">**</span> <span class="p">(</span><span class="n">tap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Copy original signal starting at tap_delay</span>
                <span class="n">copy_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">original_length</span><span class="p">,</span> <span class="n">output_length</span> <span class="o">-</span> <span class="n">tap_delay</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">copy_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">delayed</span><span class="p">[</span><span class="n">tap_delay</span> <span class="p">:</span> <span class="n">tap_delay</span> <span class="o">+</span> <span class="n">copy_length</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">waveform</span><span class="p">[:</span><span class="n">copy_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">feedback_amt</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">delayed</span>

        <span class="k">elif</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Multi-channel: (channels, time)</span>
            <span class="n">delayed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">output_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">tap</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">taps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">tap_delay</span> <span class="o">=</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="n">tap</span>
                    <span class="c1"># First tap always has amplitude 1.0, subsequent taps use feedback</span>
                    <span class="n">feedback_amt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">tap</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">feedback</span> <span class="o">**</span> <span class="p">(</span><span class="n">tap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Copy original signal starting at tap_delay</span>
                    <span class="n">copy_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">original_length</span><span class="p">,</span> <span class="n">output_length</span> <span class="o">-</span> <span class="n">tap_delay</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">copy_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">delayed</span><span class="p">[</span><span class="n">ch</span><span class="p">,</span> <span class="n">tap_delay</span> <span class="p">:</span> <span class="n">tap_delay</span> <span class="o">+</span> <span class="n">copy_length</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">waveform</span><span class="p">[</span><span class="n">ch</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">feedback_amt</span>
                        <span class="p">)</span>
            <span class="k">return</span> <span class="n">delayed</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Higher dimensions: (..., time)</span>
            <span class="c1"># Flatten to (channels, time) for processing</span>
            <span class="n">original_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">flattened</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">processed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_delay</span><span class="p">(</span><span class="n">flattened</span><span class="p">,</span> <span class="n">delay_samples</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="n">feedback</span><span class="p">)</span>
            <span class="c1"># Reshape with extended time dimension</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="n">original_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">processed</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">processed</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="PingPongDelayStrategy">
<a class="viewcode-back" href="../../api/effects.html#torchfx.PingPongDelayStrategy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PingPongDelayStrategy</span><span class="p">(</span><span class="n">DelayStrategy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply ping-pong delay alternating between left and right channels.</span>

<span class="sd">    PingPongDelayStrategy creates a stereo delay effect where echoes alternate</span>
<span class="sd">    between the left and right channels, producing a &quot;bouncing&quot; or &quot;ping-pong&quot;</span>
<span class="sd">    spatial effect. This is commonly used in music production for creating</span>
<span class="sd">    wide, spacious delay effects.</span>

<span class="sd">    The strategy requires stereo (2-channel) input. For non-stereo audio, it</span>
<span class="sd">    automatically falls back to MonoDelayStrategy.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DelayStrategy : Abstract base class for delay strategies</span>
<span class="sd">    MonoDelayStrategy : Uniform delay for all channels</span>
<span class="sd">    Delay : The effect that uses this strategy</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    **Ping-Pong Pattern:**</span>

<span class="sd">    - Odd taps (1, 3, 5, ...): Left channel → Right channel</span>
<span class="sd">    - Even taps (2, 4, 6, ...): Right channel → Left channel</span>

<span class="sd">    This creates the characteristic bouncing effect where the delay appears to</span>
<span class="sd">    move back and forth between the left and right speakers.</span>

<span class="sd">    **Fallback Behavior:**</span>

<span class="sd">    If the input is not stereo (2 channels), the strategy automatically falls</span>
<span class="sd">    back to MonoDelayStrategy to process the audio.</span>

<span class="sd">    **Output Length:**</span>

<span class="sd">    The output is extended to accommodate all delayed taps:</span>
<span class="sd">    ``output_length = input_length + (delay_samples * taps)``</span>

<span class="sd">    **Tap Amplitude:**</span>

<span class="sd">    Same as MonoDelayStrategy:</span>

<span class="sd">    - Tap 1: amplitude = 1.0</span>
<span class="sd">    - Tap n (n &gt; 1): amplitude = feedback^(n-1)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create ping-pong delay effect:</span>

<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; from torchfx.effect import PingPongDelayStrategy</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;stereo_audio.wav&quot;)  # Must be stereo</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.Delay(delay_samples=2205, taps=6, feedback=0.5, mix=0.4,</span>
<span class="sd">    ...                  strategy=PingPongDelayStrategy())</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | delay</span>

<span class="sd">    BPM-synced ping-pong delay:</span>

<span class="sd">    &gt;&gt;&gt; delay = fx.Delay(bpm=120, delay_time=&quot;1/8&quot;, taps=8, feedback=0.6, mix=0.3,</span>
<span class="sd">    ...                  strategy=PingPongDelayStrategy())</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | delay</span>

<span class="sd">    Combine with reverb for spacious effect:</span>

<span class="sd">    &gt;&gt;&gt; reverb = fx.Reverb(delay=4410, decay=0.6, mix=0.2)</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.Delay(bpm=128, delay_time=&quot;1/4&quot;, taps=4, feedback=0.5, mix=0.3,</span>
<span class="sd">    ...                  strategy=PingPongDelayStrategy())</span>
<span class="sd">    &gt;&gt;&gt; processed = wave | reverb | delay</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PingPongDelayStrategy.apply_delay">
<a class="viewcode-back" href="../../api/effects.html#torchfx.PingPongDelayStrategy.apply_delay">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_delay</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">delay_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">taps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">feedback</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply ping-pong delay (alternates between channels).</span>

<span class="sd">        Output length is extended to accommodate all delayed taps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waveform : Tensor</span>
<span class="sd">            Input audio tensor. Should be stereo with shape (2, time) or</span>
<span class="sd">            (..., 2, time). For non-stereo input, falls back to MonoDelayStrategy.</span>
<span class="sd">        delay_samples : int</span>
<span class="sd">            Delay time in samples for each tap.</span>
<span class="sd">        taps : int</span>
<span class="sd">            Number of delay taps (echoes).</span>
<span class="sd">        feedback : float</span>
<span class="sd">            Feedback amount for taps 2 and beyond.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor</span>
<span class="sd">            Delayed audio with ping-pong effect. Shape matches input except</span>
<span class="sd">            extended time dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Not stereo, fall back to mono</span>
            <span class="k">return</span> <span class="n">MonoDelayStrategy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_delay</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">delay_samples</span><span class="p">,</span> <span class="n">taps</span><span class="p">,</span> <span class="n">feedback</span><span class="p">)</span>

        <span class="c1"># Calculate required output length</span>
        <span class="n">original_length</span> <span class="o">=</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">max_delay_samples</span> <span class="o">=</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="n">taps</span>
        <span class="n">output_length</span> <span class="o">=</span> <span class="n">original_length</span> <span class="o">+</span> <span class="n">max_delay_samples</span>

        <span class="c1"># waveform: (2, time) or (..., 2, time)</span>
        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Simple case: (2, time)</span>
            <span class="n">delayed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">output_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tap</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">taps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tap_delay</span> <span class="o">=</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="n">tap</span>
                <span class="c1"># First tap always has amplitude 1.0, subsequent taps use feedback</span>
                <span class="n">feedback_amt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">tap</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">feedback</span> <span class="o">**</span> <span class="p">(</span><span class="n">tap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Copy length for this tap</span>
                <span class="n">copy_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">original_length</span><span class="p">,</span> <span class="n">output_length</span> <span class="o">-</span> <span class="n">tap_delay</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">copy_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Odd taps: left delays to right, even taps: right delays to left</span>
                    <span class="k">if</span> <span class="n">tap</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Left -&gt; Right</span>
                        <span class="n">delayed</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">tap_delay</span> <span class="p">:</span> <span class="n">tap_delay</span> <span class="o">+</span> <span class="n">copy_length</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">waveform</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">feedback_amt</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Right -&gt; Left</span>
                        <span class="n">delayed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">tap_delay</span> <span class="p">:</span> <span class="n">tap_delay</span> <span class="o">+</span> <span class="n">copy_length</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">waveform</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">feedback_amt</span>
                        <span class="p">)</span>
            <span class="k">return</span> <span class="n">delayed</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Higher dimensions: (..., 2, time)</span>
            <span class="n">original_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">original_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_length</span>
            <span class="n">delayed</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tap</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">taps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tap_delay</span> <span class="o">=</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="n">tap</span>
                <span class="c1"># First tap always has amplitude 1.0, subsequent taps use feedback</span>
                <span class="n">feedback_amt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">tap</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">feedback</span> <span class="o">**</span> <span class="p">(</span><span class="n">tap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Copy length for this tap</span>
                <span class="n">copy_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">original_length</span><span class="p">,</span> <span class="n">output_length</span> <span class="o">-</span> <span class="n">tap_delay</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">copy_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tap</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Left -&gt; Right</span>
                        <span class="n">delayed</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tap_delay</span> <span class="p">:</span> <span class="n">tap_delay</span> <span class="o">+</span> <span class="n">copy_length</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">waveform</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">feedback_amt</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Right -&gt; Left</span>
                        <span class="n">delayed</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tap_delay</span> <span class="p">:</span> <span class="n">tap_delay</span> <span class="o">+</span> <span class="n">copy_length</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="n">waveform</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">copy_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">feedback_amt</span>
                        <span class="p">)</span>

            <span class="k">return</span> <span class="n">delayed</span></div>
</div>



<div class="viewcode-block" id="Delay">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Delay">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Delay</span><span class="p">(</span><span class="n">FX</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a delay effect with BPM-synced musical time divisions.</span>

<span class="sd">    The delay effect creates echoes of the input signal with configurable feedback.</span>
<span class="sd">    Supports BPM-synced delay times for musical applications.</span>

<span class="sd">    The delay effect is computed as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        delayed[n] = \sum_{i=1}^{taps} feedback^{i-1} \cdot x[n - i \cdot delay]</span>
<span class="sd">        y[n] = (1 - mix) x[n] + mix \cdot delayed[n]</span>

<span class="sd">    where:</span>
<span class="sd">        - x[n] is the input signal,</span>
<span class="sd">        - y[n] is the output signal,</span>
<span class="sd">        - delay is the delay time in samples,</span>
<span class="sd">        - feedback is the feedback amount (0-0.95) affecting taps 2 and beyond,</span>
<span class="sd">        - taps is the number of delay taps,</span>
<span class="sd">        - mix is the wet/dry mix parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    delay_samples : int</span>
<span class="sd">        Delay time in samples. If provided, this is used directly.</span>
<span class="sd">        Default is None (requires bpm and delay_time).</span>
<span class="sd">    bpm : float</span>
<span class="sd">        Beats per minute for BPM-synced delay. Required if delay_samples is None.</span>
<span class="sd">    delay_time : str</span>
<span class="sd">        Musical time division for BPM-synced delay. Should be a string in the format :code:`n/d[modifier]`, where:</span>

<span class="sd">        * :code:`n/d` represents the note division (e.g., :code:`1/4` for quarter note).</span>
<span class="sd">        * :code:`modifier` is optional and can be :code:`d` for dotted notes or :code:`t` for triplets.</span>

<span class="sd">        Valid examples include:</span>

<span class="sd">        * :code:`1/4`: Quarter note</span>
<span class="sd">        * :code:`1/8`: Eighth note</span>
<span class="sd">        * :code:`1/16`: Sixteenth note</span>
<span class="sd">        * :code:`1/8d`: Dotted eighth note</span>
<span class="sd">        * :code:`1/4d`: Dotted quarter note</span>
<span class="sd">        * :code:`1/8t`: Eighth note triplet</span>

<span class="sd">        Default is :code:`1/8`.</span>
<span class="sd">    fs : int | None</span>
<span class="sd">        Sample frequency (sample rate) in Hz. Required if using BPM-synced delay</span>
<span class="sd">        without Wave pipeline. When None (default), fs will be automatically inferred</span>
<span class="sd">        from the Wave object when used with the pipeline operator (wave | delay).</span>
<span class="sd">        Must be positive if provided. Default is None.</span>
<span class="sd">    feedback : float</span>
<span class="sd">        Feedback amount (0-0.95). Controls amplitude of taps 2 and beyond.</span>
<span class="sd">        First tap always has amplitude 1.0. Higher values create more prominent echoes.</span>
<span class="sd">        Default is 0.3.</span>
<span class="sd">    mix : float</span>
<span class="sd">        Wet/dry mix. 0 = dry (original signal only), 1 = wet (delayed echoes only).</span>
<span class="sd">        Default is 0.2.</span>
<span class="sd">    taps : int</span>
<span class="sd">        Number of delay taps (echoes). Each tap is delayed by delay_samples * tap_number.</span>
<span class="sd">        Default is 3.</span>
<span class="sd">    strategy : DelayStrategy | None</span>
<span class="sd">        Delay processing strategy. If None, defaults to MonoDelayStrategy.</span>
<span class="sd">        Use PingPongDelayStrategy for stereo ping-pong effect, or provide a custom</span>
<span class="sd">        strategy extending DelayStrategy. Default is None.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import torchfx as fx</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # BPM-synced delay with auto fs inference from Wave</span>
<span class="sd">    &gt;&gt;&gt; wave = fx.Wave.from_file(&quot;audio.wav&quot;)</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.effect.Delay(bpm=128, delay_time=&#39;1/8&#39;, feedback=0.3, mix=0.2)</span>
<span class="sd">    &gt;&gt;&gt; delayed = wave | delay  # fs automatically inferred from wave</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # BPM-synced delay with explicit fs</span>
<span class="sd">    &gt;&gt;&gt; waveform = torch.randn(2, 44100)  # (channels, samples)</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.effect.Delay(bpm=128, delay_time=&#39;1/8&#39;, fs=44100, feedback=0.3, mix=0.2)</span>
<span class="sd">    &gt;&gt;&gt; delayed = delay(waveform)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Direct delay in samples (no fs needed)</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.effect.Delay(delay_samples=2205, feedback=0.4, mix=0.3)</span>
<span class="sd">    &gt;&gt;&gt; delayed = delay(waveform)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Ping-pong delay with strategy</span>
<span class="sd">    &gt;&gt;&gt; delay = fx.effect.Delay(</span>
<span class="sd">    ...     bpm=128, delay_time=&#39;1/4&#39;, fs=44100,</span>
<span class="sd">    ...     feedback=0.5, mix=0.4, strategy=fx.effect.PingPongDelayStrategy()</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; delayed = delay(waveform)</span>

<span class="sd">    Author</span>
<span class="sd">    ------</span>
<span class="sd">    Uzef &lt;@itsuzef&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">delay_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bpm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delay_time</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;1/8&quot;</span><span class="p">,</span>
        <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">feedback</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">mix</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">taps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">strategy</span><span class="p">:</span> <span class="n">DelayStrategy</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>  <span class="c1"># Store for Wave.__update_config to set automatically</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bpm</span> <span class="o">=</span> <span class="n">bpm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delay_time</span> <span class="o">=</span> <span class="n">delay_time</span>

        <span class="c1"># If delay_samples is provided directly, use it</span>
        <span class="k">if</span> <span class="n">delay_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">delay_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Delay samples must be positive.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delay_samples</span> <span class="o">=</span> <span class="n">delay_samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_needs_calculation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># BPM-synced delay requires bpm parameter</span>
            <span class="k">assert</span> <span class="n">bpm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;BPM must be provided if delay_samples is not set.&quot;</span>
            <span class="k">assert</span> <span class="n">bpm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;BPM must be positive.&quot;</span>

            <span class="c1"># If fs is available now, calculate immediately</span>
            <span class="k">if</span> <span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">fs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Sample rate (fs) must be positive.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delay_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_delay_samples</span><span class="p">(</span><span class="n">bpm</span><span class="p">,</span> <span class="n">delay_time</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_needs_calculation</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Defer calculation until fs is set (by Wave.__update_config)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delay_samples</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_needs_calculation</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Validate other parameters</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">feedback</span> <span class="o">&lt;=</span> <span class="mf">0.95</span><span class="p">,</span> <span class="s2">&quot;Feedback must be between 0 and 0.95.&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">mix</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Mix must be between 0 and 1.&quot;</span>
        <span class="k">assert</span> <span class="n">taps</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Taps must be at least 1.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feedback</span> <span class="o">=</span> <span class="n">feedback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mix</span> <span class="o">=</span> <span class="n">mix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taps</span> <span class="o">=</span> <span class="n">taps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span> <span class="ow">or</span> <span class="n">MonoDelayStrategy</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_delay_samples</span><span class="p">(</span><span class="n">bpm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">delay_time</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate delay time in samples from BPM and musical division.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bpm : float</span>
<span class="sd">            Beats per minute.</span>
<span class="sd">        delay_time : str</span>
<span class="sd">            Musical time division string (e.g., &quot;1/4&quot;, &quot;1/8d&quot;, &quot;1/8t&quot;).</span>
<span class="sd">        fs : int</span>
<span class="sd">            Sample frequency in Hz.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Delay time in samples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchfx.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">MusicalTime</span>

        <span class="n">musical_time</span> <span class="o">=</span> <span class="n">MusicalTime</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">delay_time</span><span class="p">)</span>
        <span class="n">delay_sec</span> <span class="o">=</span> <span class="n">musical_time</span><span class="o">.</span><span class="n">duration_seconds</span><span class="p">(</span><span class="n">bpm</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">delay_sec</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extend_waveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">target_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend waveform with zeros to target length along the last dimension.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">target_length</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveform</span>

        <span class="k">if</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">extended</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">target_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">extended</span><span class="p">[:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">waveform</span>
        <span class="k">elif</span> <span class="n">waveform</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">extended</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">target_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="n">extended</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">waveform</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extended_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">extended_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_length</span>
            <span class="n">extended</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">extended_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveform</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">extended</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span> <span class="n">waveform</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">waveform</span>

        <span class="k">return</span> <span class="n">extended</span>

<div class="viewcode-block" id="Delay.forward">
<a class="viewcode-back" href="../../api/effects.html#torchfx.Delay.forward">[docs]</a>
    <span class="nd">@override</span>
    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            waveform (Tensor): Tensor of audio of dimension `(..., time)` or `(channels, time)`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor: Tensor of delayed audio. Output length is extended to accommodate delayed echoes.</span>
<span class="sd">            The output will be longer than the input by up to `delay_samples * taps` samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy calculation of delay_samples if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_calculation</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Sample rate (fs) is required for BPM-synced delay.&quot;</span>
                <span class="s2">&quot;Either provide fs parameter or use with Wave pipeline (wave | delay).&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Sample rate (fs) must be positive.&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;BPM must be set for BPM-synced delay.&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">delay_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_delay_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bpm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_needs_calculation</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Apply delay using strategy pattern</span>
        <span class="n">delayed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">apply_delay</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">taps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feedback</span><span class="p">)</span>

        <span class="c1"># Extend original waveform to match delayed length for mixing</span>
        <span class="n">waveform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_waveform</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span> <span class="n">delayed</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Wet/dry mix</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">waveform</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mix</span> <span class="o">*</span> <span class="n">delayed</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>

</pre></div>
<div class="section ablog__blog_comments">
   
</div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2026, Matteo Spanio.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>